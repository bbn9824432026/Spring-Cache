
# 1 — Core idea & high-level flow

Spring Cache provides a *simple abstraction* over caching stores so you can program against `Cache` and `CacheManager` without coupling to Redis/Ehcache/Caffeine/etc.

Typical call flow for an annotated method (`@Cacheable`):

1. `@EnableCaching` registers the infrastructure (advisors/interceptors, operation source).
2. A proxy/advisor intercepts the method call.
3. The interceptor asks a `CacheOperationSource` (annotation parser) what caching operations apply.
4. A `CacheResolver` / `CacheManager` resolves `Cache` objects by name.
5. A `KeyGenerator` builds the cache key (or you supply an SpEL `key`).
6. The `Cache` implementation (`get`, `put`, `evict`...) is invoked.
7. The interceptor returns cached value or delegates to the target method and then updates cache.

# 2 — Most important API types (quick reference)

* `org.springframework.cache.Cache`

  * Core cache interface. Key methods:

    * `String getName()`
    * `Object getNativeCache()`
    * `Cache.ValueWrapper get(Object key)`
    * `<T> T get(Object key, Class<T> type)`
    * `<T> T get(Object key, Callable<T> valueLoader)` — *atomic compute-if-absent style*
    * `void put(Object key, @Nullable Object value)`
    * `Cache.ValueWrapper putIfAbsent(Object key, @Nullable Object value)`
    * `void evict(Object key)`
    * `void clear()`
  * `ValueWrapper` holds the cached value (method `get()`).

* `org.springframework.cache.CacheManager`

  * `Cache getCache(String name)`
  * `Collection<String> getCacheNames()`
  * Implementations: `ConcurrentMapCacheManager`, `SimpleCacheManager`, `RedisCacheManager`, `EhCacheCacheManager`, etc.
  * Note: Some managers create caches lazily (e.g., `ConcurrentMapCacheManager`) while others may require explicit configuration.

* `org.springframework.cache.interceptor.CacheInterceptor` (the runtime AOP interceptor)

  * Implements the caching advice; uses `CacheOperationSource`, `CacheResolver`, `KeyGenerator`, `CacheErrorHandler`.

* `org.springframework.cache.interceptor.CacheOperationSource`

  * Decides what cache operation(s) apply for a given method. The common implementation is `AnnotationCacheOperationSource` (parses `@Cacheable`, `@CachePut`, `@CacheEvict`, `@Caching`).

* `org.springframework.cache.interceptor.CacheResolver`

  * `Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context)`
  * Default `SimpleCacheResolver` resolves using the `CacheManager`.

* `org.springframework.cache.interceptor.KeyGenerator`

  * `Object generate(Object target, Method method, Object... params)`
  * Default: `SimpleKeyGenerator`.

* `org.springframework.cache.interceptor.CacheErrorHandler`

  * Methods to handle errors (get/put/evict/clear). Useful to make caches fail-safe.

* `org.springframework.cache.annotation.CacheConfig`

  * Class-level defaults (cacheNames, keyGenerator, cacheManager, cacheResolver).

# 3 — Annotations and their semantics (precise)

* `@Cacheable`

  * Purpose: *read-through* style — check cache first, on miss execute method and store result.
  * Important attributes:

    * `value` / `cacheNames` — cache(s) to use.
    * `key` — SpEL expression to compute key (`#id`, `#root.methodName`, `#a0`).
    * `keyGenerator` — bean name of `KeyGenerator`.
    * `condition` — SpEL boolean evaluated **before** method call (if false, skip caching attempt).
    * `unless` — SpEL boolean evaluated **after** method returns; if true, the result is *not stored*.
    * `sync` (boolean) — when supported, attempts to prevent a cache-stampede by synchronizing cache population for concurrent threads.
  * Ordering: `condition` (pre) → method execution (if miss) → `unless` (post) to decide final storage.

* `@CachePut`

  * Purpose: always execute method and *update* cache with the result (useful for updates).
  * Same attributes as `@Cacheable` (except `sync` isn't applicable).

* `@CacheEvict`

  * Purpose: remove entries.
  * Key attrs:

    * `key`
    * `allEntries` — remove all entries when true
    * `beforeInvocation` — if true, evict happens before method execution (useful if method might fail and you still want eviction).

* `@Caching`

  * Compose multiple operations (e.g., put + evict in same method).

* `@CacheConfig`

  * Sits on the class to share defaults (cacheNames, keyGenerator, cacheResolver, cacheManager).

# 4 — Key generation details & SimpleKey behavior

* Default `SimpleKeyGenerator` behavior:

  * zero args → `SimpleKey.EMPTY`
  * one arg → that single value (useful for primitives/strings)
  * multiple args → `new SimpleKey(args...)` (combines them; uses equals/hashCode)
* SpEL: `#root.methodName`, `#root.targetClass`, `#root.args`, `#a0`/`#p0`, `#result` (post-invoke), `#exception` (if available in after-throwing contexts).
* Best practice: choose unambiguous keys (avoid mutable objects as keys, or use an ID/immutable DTO).

# 5 — How Spring wires caching at startup (the internals, concise)

* `@EnableCaching` triggers the caching configuration. Spring registers:

  * a `CacheOperationSource` (annotation parser).
  * a caching advisor that matches methods with cache operations.
  * a `CacheInterceptor` (the advice) wired with:

    * `CacheOperationSource`
    * `CacheResolver` (or default built from `CacheManager`)
    * `KeyGenerator` (or default)
    * `CacheErrorHandler`
* The advisor (pointcut/advice) ensures that methods with annotation are intercepted by `CacheInterceptor`. Default mode: proxy-based AOP (JDK/CGLIB). You can switch to `@EnableCaching(mode = AdviceMode.ASPECTJ)` to use AspectJ weaving if you need interception on self-invocation.

# 6 — Programmatic usage (when you need full control)

You can use the API directly — useful for manual control or non-annotated places:

```java
CacheManager cacheManager = ctx.getBean(CacheManager.class);
Cache cache = cacheManager.getCache("users");

// compute-if-absent (atomic if cache supports it)
String value = cache.get("user::1", () -> loadUserFromDb(1L));

// simple get/put
Cache.ValueWrapper wrapper = cache.get("user::1");
if (wrapper == null) {
    String v = loadUserFromDb(1L);
    cache.put("user::1", v);
} else {
    String v = (String) wrapper.get();
}
```

Use `get(key, Callable)` for an atomic loader when supported by the `Cache` implementation — avoids double-loads when multiple threads race.

# 7 — Extension points & customization

* **Custom `Cache` implementation**: implement `org.springframework.cache.Cache` (wrap Redis client, remote store, hybrid store).
* **Custom `CacheManager`**: implement `CacheManager` to return caches with custom policies.
* **Custom `CacheResolver`**: choose caches dynamically based on method arguments or runtime conditions.
* **Custom `KeyGenerator`**: create keys that include tenant id, version, or namespacing.
* **Custom `CacheErrorHandler`**: make cache failures non-fatal (log and continue) or fail fast.
* **CacheInterceptor** properties: you can create your own `CacheInterceptor` bean and set `keyGenerator`, `errorHandler`, `cacheResolver` explicitly.

# 8 — Transactions & cache atomicity

* **Cache vs DB transaction**: by default cache operations occur immediately in the interceptor and are *not* rolled back if a surrounding transaction later fails.
* Solutions:

  * *Transaction-aware decorators:* wrap cache operations so they execute after successful commit (Spring offers transaction-aware wrappers / cache managers; many `CacheManager` builders provide `transactionAware()` to wrap caches).
  * *Use `beforeInvocation=true` on `@CacheEvict`* if you want eviction even when the method fails (careful).
* Important: ensure you design for the DB and cache consistency model you want (cache-aside is common: write DB, then evict or update cache).

# 9 — Advanced patterns & practical concerns

* **Cache-aside (recommended)** — application code reads cache, on miss loads from DB and writes cache. For writes, update DB then evict cache (or `@CachePut`).
* **Read-through / write-through** — supported by some cache-products; Spring Cache is primarily an application-side abstraction (cache-aside pattern).
* **Two-level caching** — local (Caffeine) + distributed (Redis). Use `CompositeCacheManager` or custom composite `Cache` implementation. Must handle local eviction sync across nodes (Redis pub/sub or manual invalidation).
* **Stampede protection** — use `@Cacheable(sync=true)` or `Cache.get(key, Callable)` or external locking (Redis locks) to avoid many threads loading same expensive data.
* **TTL & eviction** — handled by cache implementation (e.g., Redis TTL, Caffeine expireAfterWrite). Spring Cache handles logical put/evict; TTL config is implementation-specific.
* **Serialization** — important for distributed caches. Changing serializer invalidates existing cache entries. Use stable, explicit serializers (JSON with type-info or explicitly-versioned DTOs).
* **Metrics & instrumentation** — some cache providers provide stats (hits/misses). Expose via Micrometer / Actuator or provider-specific APIs.

# 10 — Implementations behavior you should know

* `ConcurrentMapCacheManager` / `ConcurrentMapCache` — simple in-memory; `putIfAbsent` is supported.
* `SimpleCacheManager` — holds preconfigured caches; does not create caches lazily unless configured.
* `RedisCacheManager` (Spring Data Redis) — supports per-cache configuration (TTL, serializers), can be transaction-aware via `transactionAware()`, often creates caches on demand.
* `CompositeCacheManager` — delegates to a list of managers; first non-null cache wins; useful for multi-level strategy.

# 11 — Error handling & fail-safe caching

* Implement `CacheErrorHandler` to catch runtime exceptions from cache backends and avoid propagating them to app code:

```java
public class LoggingCacheErrorHandler implements CacheErrorHandler {
    @Override
    public void handleCacheGetError(RuntimeException ex, Cache cache, Object key) {
        logger.warn("Cache GET error on {}, key={}", cache.getName(), key, ex);
    }
    // handleCachePutError, handleCacheEvictError, handleCacheClearError ...
}
```

* Register it by declaring a `CacheErrorHandler` bean or setting it into your `CacheInterceptor`.

# 12 — Practical debugging tips

* Enable logging:

  * `logging.level.org.springframework.cache=TRACE` to see high-level decisions.
  * `logging.level.org.springframework.cache.interceptor=DEBUG` to trace interceptor flow.
* Inspect caches programmatically (`cache.getNativeCache()` or provider CLI like `redis-cli`).
* Verify key values (print or log keys created by your `KeyGenerator`).
* Watch out for: self-invocation (internal calls bypass proxy), private/final methods (won’t be proxied), mistaken cache names, mismatched serializers.

# 13 — Common pitfalls & how to avoid them

* **Self-invocation** — method A calls annotated method B in same bean: B won’t be intercepted if using proxy AOP. Use AspectJ or externalize caching into another bean.
* **Mutable key objects** — avoid using mutable objects as cache keys; use IDs or immutable DTOs.
* **Changing serialization** — migrating serializers invalidates/readability issues; plan schema/versioning for cached data.
* **Assuming transactional consistency** — update DB then cache may produce stale reads; use transaction-aware caching patterns or evict-after-write.
* **Eviction across nodes** — using local caches without cross-node invalidation leads to stale caches in other instances.

# 14 — Small cheat-sheet (annotations & attributes)

* `@Cacheable(cacheNames, key, keyGenerator, condition, unless, sync)`
* `@CachePut(cacheNames, key, keyGenerator, condition)`
* `@CacheEvict(cacheNames, key, allEntries, beforeInvocation)`
* `@Caching` — wrapper for many ops
* `@CacheConfig` — set `cacheNames`, `keyGenerator`, `cacheManager`, `cacheResolver` at class level

# 15 — Hands-on checklist to explore the API

1. Read `org.springframework.cache.Cache` and call `get(key, Callable)` vs `get(key) + put()` to see atomic behavior.
2. Implement a simple custom `Cache` (wrap a `ConcurrentHashMap`) to understand `putIfAbsent`, `ValueWrapper`, `clear()`.
3. Register a custom `KeyGenerator` and compare keys produced by `SimpleKeyGenerator`.
4. Create a `CacheErrorHandler` that logs and swallows Redis outages — test by shutting Redis down.
5. Inspect how `CacheInterceptor` reads `CacheOperationSource` (annotation metadata) — put a breakpoint in interceptor to watch method invocations.
6. Try `@EnableCaching(mode = AdviceMode.ASPECTJ)` and test self-invocation interception with AspectJ weaving.

---

